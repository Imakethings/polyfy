#! /usr/bin/env sh
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, see <http://www.gnu.org/licenses/>.

SHORT="hr:s:o:"
LONG="help,rotate:,blur:,border-color:,border-width:,overlay:,size:,red,blue,green,rgb,shape:"
OPTIONS=$(getopt -o $(echo $SHORT) \
                 -l $(echo $LONG) \
                 -n "$0" \
                 -- "$@")

eval set -- "$OPTIONS"

# Default variables
border_c="white"
shape="diamond"
overlay="over"
border_w="10"
channel="rgb"
size="3"
dup_c=2

while true; do
    case "$1" in
        --red)
            [[ ! $negate =~ "r" ]] && negate="${negate}r"
            shift ;;
        --green)
            [[ ! $negate =~ "g" ]] && negate="${negate}g"
            shift ;;
        --blue)
            [[ ! $negate =~ "b" ]] && negate="${negate}b"
            shift ;;
        --rgb)
            negate="rgb"
            shift ;;
        -r|--rotate)
            rotation_f="${2%,*}"
            rotation_s="${2#*,}"
            shift 2 ;;
        -o|--overlay)
            overlay="$2"
            shift 2 ;;
        --blur)
            blur="-blur $2"
            shift 2 ;;
        --size)
            size="$2"
            shift 2 ;;
        -s|--shape)
            shape="$2"
            shift 2 ;;
        --border-width)
            border_w="$2"
            shift 2 ;;
        --border-color)
            border_c="$2"
            shift 2 ;;
        -h|--help)
            echo "
$(tput bold)NAME$(tput sgr0)
    Polyfy - Add cool polygons to any wallpaper

$(tput bold)SYNOPSIS$(tput sgr0)
    polyfy $(tput bold)[options]$(tput sgr0) $(tput bold)[file...]$(tput sgr0)

$(tput bold)DESCRIPTION$(tput sgr0)
    A short description about it.

$(tput bold)OPTIONS$(tput sgr0)
    $(tput bold)-h, --help $(tput sgr0)
        You're looking at it.

    $(tput bold)-r, --rotate$(tput sgr0) <first>,<second>
        Specify the rotations done on the first and second polygon. You are to
        split the degrees with a ',' delimiter. These values extend the
        exisiting (default) values.

            | Shape    | first | second |
            |---------------------------|
            | Diamond  | 45    | *      |
            | Triangle | 0     | 180    |
            | Square   | 0     | 45     |
            | Circle   | 0     | 0      |

    $(tput bold)--border-width$(tput sgr0) <number>
        The border width.

        The default value is 10.

    $(tput bold)--border-color$(tput sgr0) <color>
        The color of the border.

        The default calue is white.

    $(tput bold)--blur$(tput sgr0) <radius>x<sigma>
        Amount to blur the image excluding the area inside polygon. You are to
        split the values with a 'x'. The important setting in the above is the
        second sigma value. It can be thought of as an approximation of just
        how much your want the image to 'spread' or blur, in pixels. Think of
        it as the size of the brush used to blur the image. The numbers are
        floating point values, so you can use a very small value like '0.5'.

        The first value radius, is also important as it controls how big an
        area the operator should look at when spreading pixels. This value
        should typically be either '0' or at a minimum double that of the sigma.

        The default is 0x0 for every shape.

    $(tput bold)--size$(tput sgr0) <number>
        The size of polygon as a fraction of image height.

        The default value is 3.

    $(tput bold)-s, --shape$(tput sgr0) <type>
        What shape should be drawn. You can find the default values of every
        shape in the $(tput bold)--rotate$(tput sgr0) section.
        The available shapes are: Diamond, square, circle, triangle.

        By default the shape will be a diamond.

    $(tput bold)--red, --blue, --green$(tput sgr0)
        Specify which color channels to negate. None of these flags take any
        argument and can be specified in any sequence.

            --red --blue --green
            --blue --green
            --red

        Alternatively you can also use $(tput bold)--rgb$(tput sgr0) to negate
        all the channels. This is only shorthand for specify all the flags seperately.

        By default there will be no negated channels.

    $(tput bold)-o, --overlay$(tput sgr0) <type>
        Draw the second polygon over or under the first, or not at all.

        | Type    | Description                                 |
        |-------------------------------------------------------|
        | Under   | Draw a second polying beneath the first one |
        | Over    | Draw a second polygon over the first one    |
        | None    | Don't draw a second polygon                 |

        The default will be 'over'.
            "
            exit  ;;
        --) shift
            break ;;
        * ) break ;;
    esac
done

[[ -n $negate ]] && negate="-channel $negate -negate"
[[ -f ${1} ]] && {
    file_f="${1//~/$HOME}"; shift
    [[ -f ${1} ]] && {
        file_s="${1//~/$HOME}"; shift
    } || {
        file_s=$file_f
    }
} || {
    echo "You did not specify a file."
    exit 0
}

image_h=$(identify -format "%h" $file_f)
image_w=$(identify -format "%w" $file_f)
directory=$(dirname $file_f)
filename=$(basename ${file_f%.*})
format=$(basename ${file_f##*.})

while [[ -e $directory/$filename-polyfy"$dup_c".$format ]]; do
    let dup_c++
done
filename="$directory/$filename-polyfy"$dup_c".$format"

triangle() {
    length=$(echo "$image_h / $size" | bc -l | awk '{print int($1 + 0.5)}')
    height=$(echo "$length * sqrt(3) / 2" | bc -l | awk '{print int($1 + 0.5)}')
    rotate_s="180"
    rotate_f="0"
    path="polygon $((length / 2)),0 $length,$height 0,$height";
}

square() {
    length=$(echo "$image_h / $size" | bc -l | awk '{print int($1 + 0.5)}')
    height=$length
    rotate_s="45"
    rotate_f="0"
    path="rectangle 0,0 $length,$height";
}

diamond() {
    square
    rotate_f="45"
}

circle() {
    length=$(echo "$image_h / $size" | bc -l | awk '{print int($1 + 0.5)}');
    height=$length
    rotate_s="0"
    rotate_f="0"
    path="circle $((length/2)),$((height/2)) $((length/2)),$border_w"
}

# Execute the assigned shape as function.
$shape

convert -size "$length"x"$height" xc:none -fill black -draw "$path" \
        -background none -rotate $((rotation_f+rotate_f)) /tmp/polyfy1.png

# Cut out the first polygon from the original image and negate it.
convert $file_s /tmp/polyfy1.png -gravity center -alpha set -compose Dstin \
        -composite $negate -trim +repage /tmp/polyfy2.png

[[ $border_w -ne 0 ]] && {
    # Draw the border.
    convert -size "$length"x"$height" xc:none -stroke $border_c \
            -strokewidth $border_w -fill none -draw "$path" -background none \
            -rotate $((rotation_f+rotate_f)) /tmp/polyfy1.png
    case $overlay in
        over)
            # Combine the border and rotated border.
            convert -gravity center -background none /tmp/polyfy1.png \
                    -rotate $((rotation_s+rotate_s)) /tmp/polyfy1.png \
                    -compose Over -composite /tmp/polyfy1.png
            # Place borders over clipping
            convert -gravity center /tmp/polyfy1.png /tmp/polyfy2.png \
                    -compose DstOver -composite /tmp/polyfy2.png
            ;;
        under)
            # Place rotated border under clipping
            convert -gravity center -background none /tmp/polyfy1.png \
                    -rotate $((rotation_s+rotate_s)) /tmp/polyfy2.png \
                    -compose Over -composite /tmp/polyfy2.png
            # Place border over clipping
            convert -gravity center -background none /tmp/polyfy2.png \
                    /tmp/polyfy1.png -compose Over -composite /tmp/polyfy2.png
            ;;
        none)
            # Place border over clipping.
            convert -gravity center /tmp/polyfy1.png /tmp/polyfy2.png \
                    -compose DstOver -composite /tmp/polyfy2.png
            ;;
    esac
}

# Combine clipping and original image, apply blur
convert -gravity center $file_f $blur /tmp/polyfy2.png -compose Over -composite $filename
# Remove temporary files.
rm -f /tmp/polyfy{1,2}.png
# Tell the user where and what.
echo "file saved to $filename"
